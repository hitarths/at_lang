\documentclass[a4paper, 12pt, notitlepage] {article}
\usepackage{color}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{turnstile}
\usepackage{centernot}
\usepackage{mathtools}

\usepackage{listings}
\renewcommand{\thesubsection}{\alph{subsection}}


\newcommand{\hide}[1]{}
\newcommand{\mscmt}[1]{{\color{blue} \tiny{Srivas: {#1}}}}
\newcommand{\bcmt}[1]{{\color{green} \tiny{Bhishma: {#1}}}}
\newcommand{\hcmt}[1]{{\color{magenta} \tiny{Hitarth: {#1}}}}


\usepackage{amsmath} % American mathematical society package for matrices etc.
\usepackage{amssymb} %American mathematical society symbols
\author{Hitarth \\ Bhishmaraj}
\title{STM Project Proposal}
\date{} %This will make sure that date is not shown by \maketitle command
\begin{document}
\maketitle		


\begin{center}
MSc CS Students, CMI
\end{center}
\begin{center}
October 24, 2019
\end{center}
\newpage

\section{Introduction}

Solver-aided programming language/framework, such as Rosette~\cite{rosette_paper}, extend traditional programming languages with SAT/SMT-specific interface and constructs.
Such a language framework makes it easier to embed/model domain-specific artifacts/systems and exploit use of SAT/SMT solver features (UNSAT, MAX-SAT, UNSAT-CORE, etc.) for performing various constraint-solving tasks, such as symbolic verification, debugging, bug localization, and synthesis.
%
\hide{
domain-specific languages (SDSLs) are the languages, for a specific domain, which ease the construction of programs by giving us the ability to automate the task like verification, debugging and synthesis. But implementing the SDSLs from the scretch is a very hard task. To simplify our taks, we use Rosette \cite{rosette_paper}. Rosette is a framework for designing solver-aided languages, and is itself a solver-aided language embedded in Racket. Rosette helps us to easily exploit the power of SAT//SMT solver in designing solutions to domain specific constraint solving problems.\\
\\
}
%
Most of the current work in this field is focussed on arithmetic and bit-vector theories. There are tools for verification of programs in ANSI C with suitable assertions to  a limited extent, like BugAssist\cite{bugassist}, but they don't focus on other solutions like synthesis. Also it's code is not open source.\\
 \\
{\bf In this project} we propose to use Rosette-Racket for analysis ($verification$, $debugging$, and \emph{bug-fixing}) of array manipulating programs.
An array theory poses a challenge for symbolic analysis as it is undecidable, in general, because it requires quantifier instantiation.
%\mscmt{Please check moodle under arraydecproc for the paper; you guys seem never bother to check anything I upload on Moodle!!}\\
We simplify our problem by restricting ourselves to a decidable fragment of arrays theory~\cite{weakeqarrays}.
We simplify the problem of bug-fixing, which is essentially a synthesis problem, by restricting the grammar of the expressions that can be used in the fixes.

\section {Problem: Automatic Verification, Debugging and Fixing Array Programs}
%\mscmt{As I suggested yesterday, use a simple (buggy) array program with multiple assignment statements possibly conditional to clearly illustrate the three tasks of verification, bug-localization and bug-fixing.}\\
\hide{For the demonstration of problem, we shall give an example.}
Consider a simple program that is expected to swap the values at $i$ and $j$ index of an array $a$ if they are not in ascending order.
\hide{We are writing the program in C-like syntax for demonstration only, in practice, the program will be written in the grammar defined by our language with the pre/post conditions.}
We have deliberately introduced a {\bf bug} in line~5 of the program by using $j$ instead of $i$ in the array select to preserve the post-assertion\\ 

\begin{lstlisting}[language=C, mathescape=true]
1: int[10] a;
2: unsigned int i, j;
3: ${\bf @Pre:  assume}(i<10~\&\&~j <10)$
4: if (a[i] <= a[j]) {
5:    temp = a[j]; //Bug!!
6:    a[i] = a[j];
7:    a[j] = temp; }
8: ${\bf @Post:  assert}(a[i] > a[j])$
\end{lstlisting}
$ $\\
Our goal is to develop a prototype tool that does the following:
(1) \emph{verify} such program assertions; if an assertion fails (2) localize \emph{bugs} to a region (line~5) of the program, and suggest a possible fix (replace $J$ by $i$) to make the assertion true.
\section {Approach}

\mscmt{Merge this part with Approach; Note that for SMT proposal you have a limit of 2 pages.} \\
\mscmt{You can include an extended version of the grammar I have shown for Problem 3 of assignment to include array selects and updates.} \\
\mscmt{You should specify the class of fixes you will be restricting yourself to.} \\

We will covert the program in logical formula using Racket/Rosette, and then proceed to the verification. Assume that the final formula we get is $P$.\\
\\
\begin{equation}
\begin{split}
  &P \coloneqq (\\
  &(a_i = a[i] \land a_j = a[j]) \\
&\land (a[i] > a[j] \implies t = a[i]\\
& \land a' = a\{i \leftarrow a[j]\})  \\
& \land a'' = a'\{j \leftarrow t\}\\
&) \\
&\implies ((a_i > a_j \implies a[i] = a_j \land a[j] = a_i)\\
&\land (\neg (a_i > a_j) \implies a[i] = a_i \land a[j] = a_j))
\end{split}
\end{equation}
{\bf Verification:} We expect that $\neg P$ will be $UNSAT$. If it is the case, the program is verified.
\\\\
{\bf Debugging:} If $\neg P$ is $SAT$, then there is a bug in the program. We shall get the model for this $SAT$ instance, and check for the $UNSAT$ core for $P$ under this model. This, we expect, will be done with the help of Rosette. \\
\\
{\bf Synthesis:} For the sake of simplicity, {\bf we shall assume that the bug lies in the array access operations} in the program. For synthesis, we shall convert the program to a sketch by introducing \emph{holes} in the array access operations. Then, with the help of Rosette, we shall try to find out the possible substitution for the holes so that the $\neg P$ becomes $UNSAT$, and hence the program becomes correct. \\
\\

\begin{enumerate}
	\item  Describing a language which can be used to specify the array manipulating programs with the pre/post conditions and loop invariants \\
	\item Develop an interpreter for this language using Rosette which will help in converting the problem of performing the following analysis of a restricted class of array manipulating programs into instances of SMT array logic internally.
	\begin{itemize}
		\item Verifying an array manipulating program against its specification given as pre-post conditions and loop invariants (for program with loops).
		\item Localizing the location of a bug when verification fails.
		\item Synthesizing a fix for the bug when there is fix available {\bf by manipulating the array access indices}. We will allow the array access index to be replaced by any index (or index plus a constant) in the program. \\
		In this project we will focus on the bugs due to array access operations.
	\end{itemize}
	
	\item Implementation of our method within the Rosette-Racket solver-aided programming tool/language framework.\
	
	\item Experiment our implementation on a targeted class of benchmark examples.
\end{enumerate}


\section{Expected Results}
This is a work under progress being done as a project for an SMT course.
By the time of SMT School we expect to have an implementation of the tool in Rosette with results of running our tool on a set of benchmark array manipulating programs.
\hide{
We expect to have a system which can take simple array programs and help the user with verification, debugging and synthesis provided they give either pre/post conditions along with the loop invariants.
\\
Almost all the programs use arrays in one way or another, but most of the useful programs involving arrays also have loops. At least for now, our plan is not to indulge with loops. We might consider the loops if we are successful in the first phase of our project. 
}

\begin{thebibliography}{unsrt}
	
	\bibitem{rosette_paper}
	E. Torlak and R. Bodik. Growing solver-aided languages with Rosette. In Onward!, 2013.
	
	\bibitem{bugassist}
	Manu Jose and Rupak Majumdar, Cause Clue Clauses: Error Localization Using Maximum Satisfiablity, ACM SIGPLAN conference on Programming Language Design and Implementation (PLDI), June 2011, San Jose, California, USA.
	
	\bibitem{weakeqarrays}
	J. Christ and J. Hoenicke, Weakly Equivalent Arrays, SMT 2014
	
\end{thebibliography}


\end{document}